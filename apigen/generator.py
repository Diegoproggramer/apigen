"""
APIGen Core Generator Engine
The brain that generates complete FastAPI backends automatically
"""

import os
import json
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime


@dataclass
class APIEndpoint:
    """Represents a single API endpoint"""
    path: str
    method: str  # GET, POST, PUT, DELETE
    name: str
    description: str
    request_body: Optional[Dict] = None
    response_model: Optional[Dict] = None
    auth_required: bool = False
    tags: List[str] = field(default_factory=list)


@dataclass 
class DatabaseModel:
    """Represents a database table/model"""
    name: str
    fields: Dict[str, str]  # field_name: field_type
    relationships: List[str] = field(default_factory=list)
    timestamps: bool = True


@dataclass
class ProjectConfig:
    """Complete project configuration"""
    name: str
    description: str
    version: str = "0.1.0"
    database_url: str = "sqlite:///./app.db"
    auth_enabled: bool = True
    cors_enabled: bool = True
    docker_enabled: bool = True
    models: List[DatabaseModel] = field(default_factory=list)
    endpoints: List[APIEndpoint] = field(default_factory=list)
    created_at: str = field(default_factory=lambda: datetime.now().isoformat())


class APIGenerator:
    """
    ğŸš€ Main API Generator Engine
    
    Generates complete FastAPI backends from simple configurations.
    
    Usage:
        generator = APIGenerator("my_project")
        generator.add_model("User", {"name": "str", "email": "str"})
        generator.add_model("Product", {"title": "str", "price": "float"})
        generator.generate()
    """
    
    def __init__(self, project_name: str, output_dir: str = "./output"):
        self.config = ProjectConfig(
            name=project_name,
            description=f"{project_name} - Generated by APIGen"
        )
        self.output_dir = os.path.join(output_dir, project_name)
        self.generated_files: List[str] = []
        self._template_engine = TemplateEngine()
        
        print(f"âš¡ APIGen initialized for project: {project_name}")
    
    def add_model(self, name: str, fields: Dict[str, str], 
                  relationships: List[str] = None, timestamps: bool = True) -> 'APIGenerator':
        """Add a database model to the project"""
        model = DatabaseModel(
            name=name,
            fields=fields,
            relationships=relationships or [],
            timestamps=timestamps
        )
        self.config.models.append(model)
        
        # Auto-generate CRUD endpoints for this model
        self._auto_generate_endpoints(model)
        
        print(f"  ğŸ“¦ Model added: {name} ({len(fields)} fields)")
        return self  # Enable method chaining
    
    def _auto_generate_endpoints(self, model: DatabaseModel):
        """Automatically generate CRUD endpoints for a model"""
        name_lower = model.name.lower()
        name_plural = f"{name_lower}s"
        
        crud_endpoints = [
            APIEndpoint(
                path=f"/{name_plural}",
                method="GET",
                name=f"list_{name_plural}",
                description=f"Get all {name_plural}",
                tags=[model.name]
            ),
            APIEndpoint(
                path=f"/{name_plural}/{{id}}",
                method="GET", 
                name=f"get_{name_lower}",
                description=f"Get {name_lower} by ID",
                tags=[model.name]
            ),
            APIEndpoint(
                path=f"/{name_plural}",
                method="POST",
                name=f"create_{name_lower}",
                description=f"Create new {name_lower}",
                request_body=model.fields,
                auth_required=True,
                tags=[model.name]
            ),
            APIEndpoint(
                path=f"/{name_plural}/{{id}}",
                method="PUT",
                name=f"update_{name_lower}",
                description=f"Update {name_lower}",
                request_body=model.fields,
                auth_required=True,
                tags=[model.name]
            ),
            APIEndpoint(
                path=f"/{name_plural}/{{id}}",
                method="DELETE",
                name=f"delete_{name_lower}",
                description=f"Delete {name_lower}",
                auth_required=True,
                tags=[model.name]
            ),
        ]
        
        self.config.endpoints.extend(crud_endpoints)
    
    def set_database(self, url: str) -> 'APIGenerator':
        """Set database connection URL"""
        self.config.database_url = url
        print(f"  ğŸ—„ï¸ Database: {url}")
        return self
    
    def enable_auth(self, enabled: bool = True) -> 'APIGenerator':
        """Enable/disable authentication"""
        self.config.auth_enabled = enabled
        print(f"  ğŸ” Auth: {'enabled' if enabled else 'disabled'}")
        return self
    
    def enable_cors(self, enabled: bool = True) -> 'APIGenerator':
        """Enable/disable CORS"""
        self.config.cors_enabled = enabled
        return self
    
    def enable_docker(self, enabled: bool = True) -> 'APIGenerator':
        """Enable/disable Docker support"""
        self.config.docker_enabled = enabled
        return self
    
    def generate(self) -> Dict[str, Any]:
        """
        ğŸš€ Generate the complete FastAPI project!
        
        Returns:
            Dict with generation results and statistics
        """
        print(f"\n{'='*60}")
        print(f"ğŸš€ GENERATING PROJECT: {self.config.name}")
        print(f"{'='*60}\n")
        
        # Create output directory
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Generate all project files
        steps = [
            ("ğŸ“ Project structure", self._generate_structure),
            ("ğŸ—„ï¸ Database models", self._generate_models),
            ("ğŸ“‹ Pydantic schemas", self._generate_schemas),
            ("ğŸ”€ API routers", self._generate_routers),
            ("ğŸ” Authentication", self._generate_auth),
            ("âš™ï¸ Configuration", self._generate_config),
            ("ğŸš€ Main application", self._generate_main),
            ("ğŸ“¦ Requirements", self._generate_requirements),
            ("ğŸ³ Docker files", self._generate_docker),
            ("ğŸ“– Documentation", self._generate_docs),
        ]
        
        results = {}
        total_lines = 0
        
        for step_name, step_func in steps:
            try:
                lines = step_func()
                total_lines += lines
                results[step_name] = {"status": "âœ…", "lines": lines}
                print(f"  {step_name}: âœ… ({lines} lines)")
            except Exception as e:
                results[step_name] = {"status": "âŒ", "error": str(e)}
                print(f"  {step_name}: âŒ ({e})")
        
        # Summary
        summary = {
            "project_name": self.config.name,
            "total_files": len(self.generated_files),
            "total_lines": total_lines,
            "models": len(self.config.models),
            "endpoints": len(self.config.endpoints),
            "output_dir": self.output_dir,
            "steps": results,
        }
        
        print(f"\n{'='*60}")
        print(f"âœ… GENERATION COMPLETE!")
        print(f"   ğŸ“ Files: {summary['total_files']}")
        print(f"   ğŸ“ Lines: {summary['total_lines']}")
        print(f"   ğŸ“¦ Models: {summary['models']}")
        print(f"   ğŸ”€ Endpoints: {summary['endpoints']}")
        print(f"   ğŸ“‚ Output: {self.output_dir}")
        print(f"{'='*60}\n")
        
        # Save config
        self._save_config(summary)
        
        return summary
    
    def _generate_structure(self) -> int:
        """Create project directory structure"""
        dirs = [
            "",
            "app",
            "app/api",
            "app/api/v1",
            "app/core",
            "app/models",
            "app/schemas",
            "app/services",
            "app/middleware",
            "tests",
            "tests/api",
            "migrations",
        ]
        
        for d in dirs:
            path = os.path.join(self.output_dir, d)
            os.makedirs(path, exist_ok=True)
            
            # Create __init__.py for Python packages
            if d.startswith("app") or d.startswith("tests"):
                init_file = os.path.join(path, "__init__.py")
                self._write_file(init_file, f'"""{d} package"""\n')
        
        return len(dirs)
    
    def _generate_models(self) -> int:
        """Generate SQLAlchemy database models"""
        lines = 0
        
        for model in self.config.models:
            code = self._template_engine.render_model(model)
            filepath = os.path.join(
                self.output_dir, "app", "models", f"{model.name.lower()}.py"
            )
            self._write_file(filepath, code)
            lines += code.count('\n')
        
        # Generate base model
        base_code = self._template_engine.render_base_model()
        self._write_file(
            os.path.join(self.output_dir, "app", "models", "base.py"),
            base_code
        )
        lines += base_code.count('\n')
        
        return lines
    
    def _generate_schemas(self) -> int:
        """Generate Pydantic schemas"""
        lines = 0
        
        for model in self.config.models:
            code = self._template_engine.render_schema(model)
            filepath = os.path.join(
                self.output_dir, "app", "schemas", f"{model.name.lower()}.py"
            )
            self._write_file(filepath, code)
            lines += code.count('\n')
        
        return lines
    
    def _generate_routers(self) -> int:
        """Generate API route handlers"""
        lines = 0
        
        # Group endpoints by model
        model_names = {m.name for m in self.config.models}
        
        for model in self.config.models:
            model_endpoints = [
                ep for ep in self.config.endpoints 
                if model.name in ep.tags
            ]
            code = self._template_engine.render_router(model, model_endpoints)
            filepath = os.path.join(
                self.output_dir, "app", "api", "v1", f"{model.name.lower()}.py"
            )
            self._write_file(filepath, code)
            lines += code.count('\n')
        
        return lines
    
    def _generate_auth(self) -> int:
        """Generate authentication system"""
        if not self.config.auth_enabled:
            return 0
        
        code = self._template_engine.render_auth()
        filepath = os.path.join(self.output_dir, "app", "core", "auth.py")
        self._write_file(filepath, code)
        return code.count('\n')
    
    def _generate_config(self) -> int:
        """Generate configuration files"""
        code = self._template_engine.render_config(self.config)
        filepath = os.path.join(self.output_dir, "app", "core", "config.py")
        self._write_file(filepath, code)
        return code.count('\n')
    
    def _generate_main(self) -> int:
        """Generate main FastAPI application file"""
        code = self._template_engine.render_main(self.config)
        filepath = os.path.join(self.output_dir, "main.py")
        self._write_file(filepath, code)
        return code.count('\n')
    
    def _generate_requirements(self) -> int:
        """Generate requirements.txt"""
        code = self._template_engine.render_requirements()
        filepath = os.path.join(self.output_dir, "requirements.txt")
        self._write_file(filepath, code)
        return code.count('\n')
    
    def _generate_docker(self) -> int:
        """Generate Docker configuration"""
        if not self.config.docker_enabled:
            return 0
        
        lines = 0
        
        # Dockerfile
        dockerfile = self._template_engine.render_dockerfile()
        self._write_file(os.path.join(self.output_dir, "Dockerfile"), dockerfile)
        lines += dockerfile.count('\n')
        
        # docker-compose.yml
        compose = self._template_engine.render_docker_compose(self.config)
        self._write_file(os.path.join(self.output_dir, "docker-compose.yml"), compose)
        lines += compose.count('\n')
        
        return lines
    
    def _generate_docs(self) -> int:
        """Generate project documentation"""
        code = self._template_engine.render_readme(self.config)
        filepath = os.path.join(self.output_dir, "README.md")
        self._write_file(filepath, code)
        return code.count('\n')
    
    def _write_file(self, filepath: str, content: str):
        """Write content to file and track it"""
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(content)
        self.generated_files.append(filepath)
    
    def _save_config(self, summary: Dict):
        """Save generation config as JSON"""
        config_path = os.path.join(self.output_dir, "apigen.json")
        with open(config_path, 'w', encoding='utf-8') as f:
            json.dump(summary, f, indent=2, default=str)
        self.generated_files.append(config_path)


class TemplateEngine:
    """
    ğŸ”§ Template Engine for generating code files
    Renders Python code from templates and configurations
    """
    
    def render_model(self, model: DatabaseModel) -> str:
        """Generate SQLAlchemy model code"""
        fields_code = []
        for field_name, field_type in model.fields.items():
            sa_type = self._python_to_sqlalchemy(field_type)
            fields_code.append(f"    {field_name} = Column({sa_type})")
        
        if model.timestamps:
            fields_code.append("    created_at = Column(DateTime, default=datetime.utcnow)")
            fields_code.append("    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)")
        
        fields_str = "\n".join(fields_code)
        
        return f'''"""
{model.name} Database Model
Auto-generated by APIGen
"""

from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, Text, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime
from app.models.base import Base


class {model.name}(Base):
    """SQLAlchemy model for {model.name}"""
    
    __tablename__ = "{model.name.lower()}s"
    
    id = Column(Integer, primary_key=True, index=True, autoincrement=True)
{fields_str}
    
    def __repr__(self):
        return f"<{model.name}(id={{self.id}})>"
    
    def to_dict(self):
        """Convert model to dictionary"""
        return {{
            col.name: getattr(self, col.name)
            for col in self.__table__.columns
        }}
'''
    
    def render_base_model(self) -> str:
        """Generate base SQLAlchemy model"""
        return '''"""
Base Database Model
Auto-generated by APIGen
"""

from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

Base = declarative_base()


def get_engine(database_url: str):
    """Create database engine"""
    return create_engine(database_url, echo=False)


def get_session(engine):
    """Create database session"""
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    return SessionLocal()


def init_db(engine):
    """Initialize database tables"""
    Base.metadata.create_all(bind=engine)
'''
    
    def render_schema(self, model: DatabaseModel) -> str:
        """Generate Pydantic schema code"""
        fields_code = []
        optional_fields = []
        
        for field_name, field_type in model.fields.items():
            py_type = self._normalize_type(field_type)
            fields_code.append(f"    {field_name}: {py_type}")
            optional_fields.append(f"    {field_name}: Optional[{py_type}] = None")
        
        fields_str = "\n".join(fields_code)
        optional_str = "\n".join(optional_fields)
        
        return f'''"""
{model.name} Pydantic Schemas
Auto-generated by APIGen
"""

from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime


class {model.name}Base(BaseModel):
    """{model.name} base schema"""
{fields_str}


class {model.name}Create({model.name}Base):
    """Schema for creating {model.name}"""
    pass


class {model.name}Update(BaseModel):
    """Schema for updating {model.name}"""
{optional_str}


class {model.name}Response({model.name}Base):
    """Schema for {model.name} response"""
    id: int
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True


class {model.name}ListResponse(BaseModel):
    """Schema for list of {model.name}"""
    items: List[{model.name}Response]
    total: int
    page: int = 1
    per_page: int = 10
'''
    
    def render_router(self, model: DatabaseModel, endpoints: List[APIEndpoint]) -> str:
        """Generate FastAPI router code"""
        name_lower = model.name.lower()
        name_plural = f"{name_lower}s"
        
        return f'''"""
{model.name} API Router
Auto-generated by APIGen
"""

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List, Optional
from app.schemas.{name_lower} import (
    {model.name}Create, 
    {model.name}Update, 
    {model.name}Response,
    {model.name}ListResponse
)
from app.models.{name_lower} import {model.name}
from app.core.database import get_db

router = APIRouter(prefix="/{name_plural}", tags=["{model.name}"])


@router.get("/", response_model={model.name}ListResponse)
async def list_{name_plural}(
    page: int = Query(1, ge=1),
    per_page: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """Get all {name_plural} with pagination"""
    offset = (page - 1) * per_page
    total = db.query({model.name}).count()
    items = db.query({model.name}).offset(offset).limit(per_page).all()
    
    return {{
        "items": items,
        "total": total,
        "page": page,
        "per_page": per_page
    }}


@router.get("/{{item_id}}", response_model={model.name}Response)
async def get_{name_lower}(item_id: int, db: Session = Depends(get_db)):
    """Get {name_lower} by ID"""
    item = db.query({model.name}).filter({model.name}.id == item_id).first()
    if not item:
        raise HTTPException(status_code=404, detail="{model.name} not found")
    return item


@router.post("/", response_model={model.name}Response, status_code=201)
async def create_{name_lower}(
    data: {model.name}Create, 
    db: Session = Depends(get_db)
):
    """Create new {name_lower}"""
    item = {model.name}(**data.model_dump())
    db.add(item)
    db.commit()
    db.refresh(item)
    return item


@router.put("/{{item_id}}", response_model={model.name}Response)
async def update_{name_lower}(
    item_id: int, 
    data: {model.name}Update, 
    db: Session = Depends(get_db)
):
    """Update {name_lower}"""
    item = db.query({model.name}).filter({model.name}.id == item_id).first()
    if not item:
        raise HTTPException(status_code=404, detail="{model.name} not found")
    
    update_data = data.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(item, field, value)
    
    db.commit()
    db.refresh(item)
    return item


@router.delete("/{{item_id}}", status_code=204)
async def delete_{name_lower}(item_id: int, db: Session = Depends(get_db)):
    """Delete {name_lower}"""
    item = db.query({model.name}).filter({model.name}.id == item_id).first()
    if not item:
        raise HTTPException(status_code=404, detail="{model.name} not found")
    
    db.delete(item)
    db.commit()
    return None
'''
    
    def render_auth(self) -> str:
        """Generate authentication code"""
        return '''"""
Authentication System
Auto-generated by APIGen
"""

from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

# Configuration
SECRET_KEY = "your-secret-key-change-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()


def hash_password(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against hash"""
    return pwd_context.verify(plain_password, hashed_password)


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create JWT access token"""
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)


def decode_token(token: str) -> dict:
    """Decode and validate JWT token"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication token"
        )


async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Dependency to get current authenticated user"""
    token = credentials.credentials
    payload = decode_token(token)
    user_id = payload.get("sub")
    if user_id is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload"
        )
    return {"user_id": user_id, "payload": payload}
'''
    
    def render_config(self, config: ProjectConfig) -> str:
        """Generate configuration code"""
        return f\'\'\'"""
Application Configuration
Auto-generated by APIGen
"""

from pydantic_settings import BaseSettings
from typing import List


class Settings(BaseSettings):
    """Application settings"""
    
    # App
    APP_NAME: str = "{config.name}"
    APP_VERSION: str = "{config.version}"
    DEBUG: bool = True
    
    # Database
    DATABASE_URL: str = "{config.database_url}"
    
    # Auth
    SECRET_KEY: str = "change-this-in-production"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # CORS
    CORS_ORIGINS: List[str] = ["http://localhost:3000", "http://localhost:8080"]
    
    class Config:
        env_file = ".env"


settings = Settings()
\'\'\'
    
    def render_main(self, config: ProjectConfig) -> str:
        """Generate main application file"""
        router_imports = []
        router_includes = []
        
        for model in config.models:
            name_lower = model.name.lower()
            router_imports.append(
                f"from app.api.v1.{name_lower} import router as {name_lower}_router"
            )
            router_includes.append(
                f'app.include_router({name_lower}_router, prefix="/api/v1")'
            )
        
        imports_str = "\n".join(router_imports)
        includes_str = "\n".join(router_includes)
        
        cors_code = ""
        if config.cors_enabled:
            cors_code = """
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)"""
        
        return f\'\'\'"""
{config.name} - FastAPI Application
Auto-generated by APIGen âš¡
"""

from fastapi import FastAPI
from contextlib import asynccontextmanager

{imports_str}


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan events"""
    print("ğŸš€ Starting {config.name}...")
    yield
    print("ğŸ‘‹ Shutting down {config.name}...")


app = FastAPI(
    title="{config.name}",
    description="{config.description}",
    version="{config.version}",
    lifespan=lifespan
)
{cors_code}

# Include routers
{includes_str}


@app.get("/")
async def root():
    """Root endpoint"""
    return {{
        "name": "{config.name}",
        "version": "{config.version}",
        "status": "running",
        "docs": "/docs"
    }}


@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {{"status": "healthy"}}
\'\'\'
    
    def render_requirements(self) -> str:
        """Generate requirements.txt"""
        return """# Auto-generated by APIGen
fastapi>=0.104.0
uvicorn[standard]>=0.24.0
sqlalchemy>=2.0.0
pydantic>=2.0.0
pydantic-settings>=2.0.0
python-jose[cryptography]>=3.3.0
passlib[bcrypt]>=1.7.4
python-multipart>=0.0.6
alembic>=1.12.0
httpx>=0.25.0
python-dotenv>=1.0.0
"""
    
    def render_dockerfile(self) -> str:
        """Generate Dockerfile"""
        return """# Auto-generated by APIGen
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
"""
    
    def render_docker_compose(self, config: ProjectConfig) -> str:
        """Generate docker-compose.yml"""
        return f"""# Auto-generated by APIGen
version: '3.8'

services:
  api:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL={config.database_url}
    volumes:
      - .:/app
    restart: unless-stopped

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB={config.name}
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=secret
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
"""
    
    def render_readme(self, config: ProjectConfig) -> str:
        """Generate project README"""
        models_doc = ""
        for model in config.models:
            fields = ", ".join(f"`{k}`: {v}" for k, v in model.fields.items())
            models_doc += f"- **{model.name}**: {fields}\n"
        
        return f"""# {config.name}

> Auto-generated by [APIGen](https://github.com/Diegoproggramer/apigen) âš¡

## ğŸš€ Quick Start
```bash
pip install -r requirements.txt
uvicorn main:app --reload

## ğŸ“– API Documentation

Visit `http://localhost:8000/docs` for interactive API docs.

## ğŸ“¦ Models

{models_doc}

## ğŸ³ Docker

bash
docker-compose up -d

## ğŸ“ Endpoints

Total: {len(config.endpoints)} auto-generated endpoints

---
Generated with â¤ï¸ by APIGen v0.1.0
"""

def _python_to_sqlalchemy(self, python_type: str) -> str:
"""Convert Python type to SQLAlchemy column type"""
type_map = {
"str": "String(255)",
"string": "String(255)",
"int": "Integer",
"integer": "Integer",
"float": "Float",
"bool": "Boolean",
"boolean": "Boolean",
"text": "Text",
"datetime": "DateTime",
"date": "DateTime",
}
return type_map.get(python_type.lower(), "String(255)")

def _normalize_type(self, field_type: str) -> str:
"""Normalize field type to Python type"""
type_map = {
"str": "str",
"string": "str",
"int": "int",
"integer": "int",
"float": "float",
"bool": "bool",
"boolean": "bool",
"text": "str",
"datetime": "datetime",
"date": "datetime",
}
return type_map.get(field_type.lower(), "str")


**Commit message:** `feat: add core API generator engine with template system`

---

**âš ï¸ Ø§ÛŒÙ† ÙØ§ÛŒÙ„ Ø¨Ø²Ø±Ú¯Ù‡! Ú©Ù„ Ú©Ø¯ Ø±Ùˆ Ú©Ù¾ÛŒ Ú©Ù† Ùˆ Ø¨Ø°Ø§Ø± ØªÙˆØ´** âš¡ğŸš€**Ø§Ø² Ùˆ Ø§Ø³Ú©Ø±ÛŒÙ†â€ŒØ´Ø§Øª Ø¨ÙØ±Ø³Øª! âš¡ğŸš€**
